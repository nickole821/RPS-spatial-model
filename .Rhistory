list_combination <- list( # set the reaction rules according to rock-paper-scissors game
"Y_Y" = c("Y", "Y"),
"O_O" = c("O", "O"),
"B_B" = c("B", "B"),
"Y_O" = c("Y", "Y"),
"O_Y" = c("Y", "Y"),
"O_B" = c("O", "O"),
"B_O" = c("O", "O"),
"B_Y" = c("B", "B"),
"Y_B" = c("B", "B")
)
i <- paste(sort(c(a, b)), collapse = "_")
result <- list_combination[[i]]
if (is.null(result)) {
return(c(a, b))  # if the reaction is not set, it keeps the same agents
}
if (runif(1) < rate) { # test the reaction rate
return(result) # reaction
} else {
return(c(a, b)) # no reaction
}
}
get_neighbors <- function(i, j, position_matrix, plusfocal = FALSE) {
size <- nrow(position_matrix)
i_seq <- c((i - 1 - 1) %% size + 1, i, (i + 1 - 1) %% size + 1)
j_seq <- c((j - 1 - 1) %% size + 1, j, (j + 1 - 1) %% size + 1)
neighbors_matrix <- position_matrix[i_seq, j_seq]
neighbors <- as.vector(neighbors_matrix)
if (!plusfocal) {
focal_index <- which(i_seq == i) * 3 + which(j_seq == j) - 3
neighbors <- neighbors[-focal_index]
}
return(neighbors)
}
get_payoff <- function(a1, a2, payoff_matrix) {
index <- c("O" = 1, "Y" = 2, "B" = 3)
return(payoff_matrix[index[a1], index[a2]])
}
get_fitness_matrix <- function(position_matrix) {
fitness_matrix <- matrix(NA, nrow = size, ncol = size)
for (i in 1:size) {
for (j in 1:size) {
fitness_ID <- 0  # Iniciar com 0
a <- get_neighbors(i, j, position_matrix)
for (z in 1:length(a)) {
fitness_ID <- fitness_ID + get_payoff(position_matrix[i, j], a[z], payoff_matrix)
}
fitness_matrix[i, j] <- fitness_ID
}
}
return(fitness_matrix)
}
going_to_die <- function(position_matrix, prob) {
intermediate_matrix <- matrix(NA, nrow = size, ncol = size)
for (i in 1:size) {
for (j in 1:size) {
a <- runif(1, 0, 1)
if (a > prob) {
intermediate_matrix[i,j] <- "E"
} else {
intermediate_matrix[i,j] <- position_matrix[i,j]
}
}
}
return(intermediate_matrix)
}
get_new_matrix <- function(position_matrix_0, intermediate_matrix, fitness_matrix) {
new_matrix <- matrix(NA, nrow = size, ncol = size)
for (i in 1:size) {
for (j in 1:size) {
if (intermediate_matrix[i,j] == "E") {
neighbors_strategies <- get_neighbors(i, j, position_matrix_0)
neighbors_fitness <- get_neighbors(i, j, fitness_matrix)
max_fitness <- which.max(neighbors_fitness)
new_matrix[i,j] <- neighbors_strategies[max_fitness]
} else {
new_matrix[i,j] <- position_matrix_0[i,j]
}
}
}
return(new_matrix)
}
### Create initial matrix and set variables ------------------------------------
strategies <- c("O", "Y", "B") # agents in the game
a <- 2
b <- 1/a
payoff_matrix <- matrix(c(1, b, a,
a, 1, b,
b, a, 1), byrow = T, nrow = 3)
colnames(payoff_matrix) <- strategies
rownames(payoff_matrix) <- strategies
payoff_matrix # payoff matrix of the game
size <- 10
position_matrix_0 <- matrix(sample(strategies, size^2, replace = TRUE),
nrow = size, ncol = size) # random initial position
position_matrix_0
prob_death <- 0.5  # probability of death (goes from 0 to 1) equal to all players
t <- 10 #number of generations
fitness_matrix <- get_fitness_matrix(position_matrix_0)
# Step 2:
intermediate_matrix <- going_to_die(position_matrix_0, prob_death)
### Functions ------------------------------------------------------------------
reaction <- function(a, b, r) {
list_combination <- list( # set the reaction rules according to rock-paper-scissors game
"Y_Y" = c("Y", "Y"),
"O_O" = c("O", "O"),
"B_B" = c("B", "B"),
"Y_O" = c("Y", "Y"),
"O_Y" = c("Y", "Y"),
"O_B" = c("O", "O"),
"B_O" = c("O", "O"),
"B_Y" = c("B", "B"),
"Y_B" = c("B", "B")
)
i <- paste(sort(c(a, b)), collapse = "_")
result <- list_combination[[i]]
if (is.null(result)) {
return(c(a, b))  # if the reaction is not set, it keeps the same agents
}
if (runif(1) < rate) { # test the reaction rate
return(result) # reaction
} else {
return(c(a, b)) # no reaction
}
}
get_neighbors <- function(i, j, position_matrix, plusfocal = FALSE) {
size <- nrow(position_matrix)
i_seq <- c((i - 1 - 1) %% size + 1, i, (i + 1 - 1) %% size + 1)
j_seq <- c((j - 1 - 1) %% size + 1, j, (j + 1 - 1) %% size + 1)
neighbors_matrix <- position_matrix[i_seq, j_seq]
neighbors <- as.vector(neighbors_matrix)
if (!plusfocal) {
focal_index <- which(i_seq == i) * 3 + which(j_seq == j) - 3
neighbors <- neighbors[-focal_index]
}
return(neighbors)
}
get_payoff <- function(a1, a2, payoff_matrix) {
index <- c("O" = 1, "Y" = 2, "B" = 3)
return(payoff_matrix[index[a1], index[a2]])
}
get_fitness_matrix <- function(position_matrix) {
fitness_matrix <- matrix(NA, nrow = size, ncol = size)
for (i in 1:size) {
for (j in 1:size) {
fitness_ID <- 0  # Iniciar com 0
a <- get_neighbors(i, j, position_matrix)
for (z in 1:length(a)) {
fitness_ID <- fitness_ID + get_payoff(position_matrix[i, j], a[z], payoff_matrix)
}
fitness_matrix[i, j] <- fitness_ID
}
}
return(fitness_matrix)
}
going_to_die <- function(position_matrix, prob) {
intermediate_matrix <- matrix(NA, nrow = size, ncol = size)
for (i in 1:size) {
for (j in 1:size) {
a <- runif(1, 0, 1)
if (a > prob) {
intermediate_matrix[i,j] <- "E"
} else {
intermediate_matrix[i,j] <- position_matrix[i,j]
}
}
}
return(intermediate_matrix)
}
get_new_matrix <- function(position_matrix_0, intermediate_matrix, fitness_matrix) {
new_matrix <- matrix(NA, nrow = size, ncol = size)
for (i in 1:size) {
for (j in 1:size) {
if (intermediate_matrix[i,j] == "E") {
neighbors_strategies <- get_neighbors(i, j, position_matrix_0)
neighbors_fitness <- get_neighbors(i, j, fitness_matrix)
max_fitness <- which.max(neighbors_fitness)
new_matrix[i,j] <- neighbors_strategies[max_fitness]
} else {
new_matrix[i,j] <- position_matrix_0[i,j]
}
}
}
return(new_matrix)
}
### Create initial matrix and set variables ------------------------------------
strategies <- c("O", "Y", "B") # agents in the game
a <- 2
b <- 1/a
payoff_matrix <- matrix(c(1, b, a,
a, 1, b,
b, a, 1), byrow = T, nrow = 3)
colnames(payoff_matrix) <- strategies
rownames(payoff_matrix) <- strategies
payoff_matrix # payoff matrix of the game
size <- 10
position_matrix_0 <- matrix(sample(strategies, size^2, replace = TRUE),
nrow = size, ncol = size) # random initial position
position_matrix_0
prob_death <- 0.5  # probability of death (goes from 0 to 1) equal to all players
t <- 10 #number of generations
for (generation in 1:t) {
cat("Geração:", generation, "\n")  # Imprimir número da geração
# Step 1: based on the initial matrix, calculate the payoff matrix
fitness_matrix <- get_fitness_matrix(position_matrix_0)
# Step 2: select which agents are not going to reproduce on the next generation (random)
intermediate_matrix <- going_to_die(position_matrix_0, prob_death)
# Step 3: select one neighbor to reproduce and fill the cells that are empty ("E")
# based on their payoffs (bigger payoff reproduces)
new_matrix <- get_new_matrix(position_matrix_0, intermediate_matrix, fitness_matrix)
# the new matrix become the initial matrix for the next generation
position_matrix_0 <- new_matrix
}
View(new_matrix)
simulation <- function(position_matrix, payoff_matrix, num_generations, prob_death) {
# to store matrices and frequencies
all_matrices <- list(position_matrix)
frequencies <- data.frame(Generation = 0,
O = sum(position_matrix == "O") / (size^2),
Y = sum(position_matrix == "Y") / (size^2),
B = sum(position_matrix == "B") / (size^2))
# to obtain the 8' neighbors of the focal agent on the matrix with periodic boundaries
get_neighbors <- function(i, j, position_matrix) {
size <- nrow(position_matrix)
i_seq <- c((i - 1 - 1) %% size + 1, i, (i + 1 - 1) %% size + 1)
j_seq <- c((j - 1 - 1) %% size + 1, j, (j + 1 - 1) %% size + 1)
neighbors_matrix <- position_matrix[i_seq, j_seq]
neighbors <- as.vector(neighbors_matrix)
return(neighbors)
}
# to calculate the payoffs of two agents on the RPS-game
get_payoff <- function(a1, a2, payoff_matrix) {
index <- c("O" = 1, "Y" = 2, "B" = 3)
return(payoff_matrix[index[a1], index[a2]])
}
# to calculate the fitness matrix based on the initial position matrix
get_fitness_matrix <- function(position_matrix) {
fitness_matrix <- matrix(NA, nrow = size, ncol = size)
for (i in 1:size) {
for (j in 1:size) {
fitness_ID <- 0
a <- get_neighbors(i, j, position_matrix)
for (z in 1:length(a)) {
fitness_ID <- fitness_ID + get_payoff(position_matrix[i, j], a[z], payoff_matrix)
}
fitness_matrix[i, j] <- fitness_ID
}
}
return(fitness_matrix)
}
# to determine which agents are going to reproduce on the next generation (random)
going_to_die <- function(position_matrix, prob_death) {
intermediate_matrix <- matrix(NA, nrow = size, ncol = size)
for (i in 1:size) {
for (j in 1:size) {
a <- runif(1, 0, 1)
if (a > prob_death) {
intermediate_matrix[i, j] <- "E"  # agents died and the cell is empty
} else {
intermediate_matrix[i, j] <- position_matrix[i, j] # agent reproduced
}
}
}
return(intermediate_matrix)
}
# to generate the new matrix with the fittest neighbors
get_new_matrix <- function(position_matrix_0, intermediate_matrix, fitness_matrix) {
new_matrix <- matrix(NA, nrow = size, ncol = size)
for (i in 1:size) {
for (j in 1:size) {
if (intermediate_matrix[i, j] == "E") {
neighbors_strategies <- get_neighbors(i, j, position_matrix_0)
neighbors_fitness <- get_neighbors(i, j, fitness_matrix)
max_fitness <- which.max(neighbors_fitness)
new_matrix[i, j] <- neighbors_strategies[max_fitness]
} else {
new_matrix[i, j] <- position_matrix_0[i, j]
}
}
}
return(new_matrix)
}
# principal loop
for (generation in 1:num_generations) {
# step 1: calculate fitness matrix
fitness_matrix <- get_fitness_matrix(position_matrix)
# step 2: select agents to reproduce and die
intermediate_matrix <- going_to_die(position_matrix, prob_death)
# step 3: ocupying the empty spaces with fittest neighbors
new_matrix <- get_new_matrix(position_matrix, intermediate_matrix, fitness_matrix)
# save matrix
all_matrices[[generation + 1]] <- new_matrix
# save frequency
frequencies <- rbind(frequencies, data.frame(Generation = generation,
O = sum(new_matrix == "O") / (size^2),
Y = sum(new_matrix == "Y") / (size^2),
B = sum(new_matrix == "B") / (size^2)))
# new_matrix become the initial position matrix for the next generation
position_matrix <- new_matrix
}
return(list(matrices = all_matrices, frequencies = frequencies))
}
source("./r-scripts/stochastic-model/functions.R")
source("./r-scripts/stochastic-model/functions.R")
strategies <- c("O", "Y", "B") # agents in the game
a <- 2
b <- 1/a
payoff_matrix <- matrix(c(1, b, a,
a, 1, b,
b, a, 1), byrow = T, nrow = 3)
colnames(payoff_matrix) <- strategies
rownames(payoff_matrix) <- strategies
payoff_matrix # payoff matrix of the game
size <- 10
position_matrix <- matrix(sample(strategies, size^2, replace = TRUE),
nrow = size, ncol = size) # random initial position
position_matrix
prob_death <- 0.5  # probability of death (goes from 0 to 1) equal to all players
View(simulation)
simualation(position_matrix, payoff_matrix, num_generations = 100, prob_death = 0.5)
simulation(position_matrix, payoff_matrix, num_generations = 100, prob_death = 0.5)
a <- simulation(position_matrix, payoff_matrix, num_generations = 100, prob_death = 0.5)
View(a)
strategies <- c("O", "Y", "B") # agents in the game
a <- 2
b <- 1/a
payoff_matrix <- matrix(c(1, b, a,
a, 1, b,
b, a, 1), byrow = T, nrow = 3)
colnames(payoff_matrix) <- strategies
rownames(payoff_matrix) <- strategies
payoff_matrix # payoff matrix of the game
size <- 100
position_matrix <- matrix(sample(strategies, size^2, replace = TRUE),
nrow = size, ncol = size) # random initial position
position_matrix
prob_death <- 0.5  # probability of death (goes from 0 to 1) equal to all players
a <- simulation(position_matrix, payoff_matrix, num_generations = 100, prob_death = 0.5)
View(a)
a$frequencies
View(a)
strategies <- c("O", "Y", "B") # agents in the game
a <- 2
b <- 1/a
payoff_matrix <- matrix(c(1, b, a,
a, 1, b,
b, a, 1), byrow = T, nrow = 3)
colnames(payoff_matrix) <- strategies
rownames(payoff_matrix) <- strategies
payoff_matrix # payoff matrix of the game
size <- 100
position_matrix <- matrix(sample(strategies, size^2, replace = TRUE),
nrow = size, ncol = size) # random initial position
position_matrix
prob_death <- 0.5  # probability of death (goes from 0 to 1) equal to all players
resultados <- simulation(position_matrix, payoff_matrix, num_generations = 100, prob_death = 0.5)
source("./r-scripts/stochastic-model/functions.R")
resultados <- simulation(position_matrix, payoff_matrix, num_generations = 100, prob_death = 0.5)
generate_image <- function(matrix_data, generation) {
matrix_df <- matrix2longdf(matrix_data)
p <- ggplot(matrix_df, aes(x = column, y = row, fill = value)) +
geom_tile() +
scale_fill_manual(values = c("O" = "tomato2", "Y" = "gold2", "B" = "blue"),
name = "Estratégia", labels = c("Azul", "Laranja", "Amarelo")) +
scale_y_reverse() +
labs(x = element_blank(), y = element_blank()) +
theme_classic() +
theme(axis.text = element_blank(), axis.ticks = element_blank()) +
labs(title = paste("Geração:", generation)) +
theme(text = element_text(size = 20))
img_path <- paste0("./r-scripts/stochastic-model/teste", generation, ".png")
ggsave(img_path, plot = p, width = 7, height = 5, dpi = 300)
return(img_path)
}
image_paths <- c()
for (i in 1:length(resultados$matrices)) {
img_path <- generate_image(resultados$matrices[[i]], i - 1)
image_paths <- c(image_paths, img_path)
}
img_list <- lapply(image_paths, image_read)
gif <- image_animate(image_join(img_list), fps = 5) # Criar o GIF usando magick
image_write(gif, "./r-scripts/stochastic-model/teste.gif") # Salvar o GIF
file.remove(image_paths) # Limpar arquivos temporários
browseURL("./r-scripts/stochastic-model/teste.gif.gif")
source("./r-scripts/stochastic-model/functions.R")
strategies <- c("O", "Y", "B") # agents in the game
a <- 2
b <- 1/a
payoff_matrix <- matrix(c(1, b, a,
a, 1, b,
b, a, 1), byrow = T, nrow = 3)
colnames(payoff_matrix) <- strategies
rownames(payoff_matrix) <- strategies
payoff_matrix # payoff matrix of the game
size <- 100
position_matrix <- matrix(sample(strategies, size^2, replace = TRUE),
nrow = size, ncol = size) # random initial position
position_matrix
prob_death <- 0.5  # probability of death (goes from 0 to 1) equal to all players
resultados <- simulation(position_matrix, payoff_matrix, num_generations = 100, prob_death = 0.5)
generate_image <- function(matrix_data, generation, output_dir) {
# Converter matriz para formato longo (data.frame)
matrix_df <- matrix2longdf(matrix_data)
# Criar o gráfico
p <- ggplot(matrix_df, aes(x = column, y = row, fill = value)) +
geom_tile() +
scale_fill_manual(values = c("O" = "tomato2", "Y" = "gold2", "B" = "blue"),
name = "Estratégia", labels = c("Azul", "Laranja", "Amarelo")) +
scale_y_reverse() +
labs(title = paste("Geração:", generation), x = NULL, y = NULL) +
theme_classic() +
theme(axis.text = element_blank(), axis.ticks = element_blank(),
text = element_text(size = 20))
# Definir o caminho do arquivo
img_path <- file.path(output_dir, paste0("frame_", generation, ".png"))
# Salvar imagem
ggsave(img_path, plot = p, width = 7, height = 5, dpi = 300)
return(img_path)
}
# Criar diretório para salvar imagens temporárias
output_dir <- "./output/gifs/temporary"
dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
# Gerar imagens para todas as matrizes
image_paths <- map_chr(seq_along(resultados$matrices),
~ generate_image(resultados$matrices[[.x]], .x - 1, output_dir))
# Criar GIF
gif <- image_animate(image_join(lapply(image_paths, image_read)), fps = 5)
# Salvar o GIF final
gif_path <- "./output/gifs/stochastic.gif"
image_write(gif, gif_path)
# Remover arquivos temporários
unlink(output_dir, recursive = TRUE)
# Abrir o GIF no navegador
browseURL(gif_path)
df_freq <- resultados$frequencies
df_freq <- df_freq %>%
pivot_longer(cols = 2:4, names_to = "strategy", values_to = "freq")
ggplot(df_freq, aes(x = geracao, y = freq, color = as.factor(strategy))) +
geom_line(size = 1) +
theme_minimal() +
labs(x = "Gerações", y = "Frequência") +
scale_color_manual(values = c("O" = "tomato2", "Y" = "gold2", "B" = "blue"),
name = "Estratégia", labels = c("Azul", "Laranja", "Amarelo")) +
scale_y_continuous(limits = c(0, 1))
ggplot(df_freq, aes(x = Generation, y = freq, color = as.factor(strategy))) +
geom_line(size = 1) +
theme_minimal() +
labs(x = "Gerações", y = "Frequência") +
scale_color_manual(values = c("O" = "tomato2", "Y" = "gold2", "B" = "blue"),
name = "Estratégia", labels = c("Azul", "Laranja", "Amarelo")) +
scale_y_continuous(limits = c(0, 1))
source("./r-scripts/stochastic-model/functions.R")
strategies <- c("O", "Y", "B") # agents in the game
a <- 2
b <- 1/a
payoff_matrix <- matrix(c(1, b, a,
a, 1, b,
b, a, 1), byrow = T, nrow = 3)
colnames(payoff_matrix) <- strategies
rownames(payoff_matrix) <- strategies
payoff_matrix # payoff matrix of the game
size <- 100
position_matrix <- matrix(sample(strategies, size^2, replace = TRUE,
prob = c(0.5, 0.25, 0.25)),
nrow = size, ncol = size) # random initial position
position_matrix
prob_death <- 0.5  # probability of death (goes from 0 to 1) equal to all players
resultados <- simulation(position_matrix, payoff_matrix, num_generations = 100, prob_death = 0.5)
generate_image <- function(matrix_data, generation, output_dir) {
# Converter matriz para formato longo (data.frame)
matrix_df <- matrix2longdf(matrix_data)
# Criar o gráfico
p <- ggplot(matrix_df, aes(x = column, y = row, fill = value)) +
geom_tile() +
scale_fill_manual(values = c("O" = "tomato2", "Y" = "gold2", "B" = "blue"),
name = "Estratégia", labels = c("Azul", "Laranja", "Amarelo")) +
scale_y_reverse() +
labs(title = paste("Geração:", generation), x = NULL, y = NULL) +
theme_classic() +
theme(axis.text = element_blank(), axis.ticks = element_blank(),
text = element_text(size = 20))
# Definir o caminho do arquivo
img_path <- file.path(output_dir, paste0("frame_", generation, ".png"))
# Salvar imagem
ggsave(img_path, plot = p, width = 7, height = 5, dpi = 300)
return(img_path)
}
# Criar diretório para salvar imagens temporárias
output_dir <- "./output/gifs/temporary"
dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
# Gerar imagens para todas as matrizes
image_paths <- map_chr(seq_along(resultados$matrices),
~ generate_image(resultados$matrices[[.x]], .x - 1, output_dir))
# Criar GIF
gif <- image_animate(image_join(lapply(image_paths, image_read)), fps = 5)
# Salvar o GIF final
gif_path <- "./output/gifs/stochastic-freq.gif"
image_write(gif, gif_path)
# Remover arquivos temporários
unlink(output_dir, recursive = TRUE)
# Abrir o GIF no navegador
browseURL(gif_path)
df_freq <- resultados$frequencies
df_freq <- df_freq %>%
pivot_longer(cols = 2:4, names_to = "strategy", values_to = "freq")
ggplot(df_freq, aes(x = Generation, y = freq, color = as.factor(strategy))) +
geom_line(size = 1) +
theme_minimal() +
labs(x = "Gerações", y = "Frequência") +
scale_color_manual(values = c("O" = "tomato2", "Y" = "gold2", "B" = "blue"),
name = "Estratégia", labels = c("Azul", "Laranja", "Amarelo")) +
scale_y_continuous(limits = c(0, 1))
